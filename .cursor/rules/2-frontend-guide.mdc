---
alwaysApply: false
---
<rule>
# JeecgBoot项目前端指南

**本文档是前端开发的“操作手册”，全面覆盖了前端的技术栈、工程化、核心概念和开发最佳实践。**

## 1. 前端技术栈（精确版本和深度分析）

**核心框架栈：**
- **Vue 3.5.13**：Composition API + `<script setup>`语法糖
- **TypeScript 4.9.5**：全面类型支持，类型安全开发
- **Vite 6.0.7**：超快构建工具（要求Node.js 20+）
- **Ant Design Vue 4.2.6**：企业级UI组件库
- **Pinia 2.1.7**：Vue 3官方状态管理库
- **Vue Router 4.5.0**：官方路由管理器

**工程化工具链：**
- **UnoCSS**：原子化CSS引擎，替代传统CSS预处理器
- **ESLint + Prettier**：代码格式化和质量检查
- **TypeScript**：静态类型检查
- **Vite插件生态**：
  - `@vitejs/plugin-vue`：Vue 3支持
  - `@vitejs/plugin-vue-jsx`：JSX支持
  - `vite-plugin-svg-icons`：SVG图标处理
  - `vite-plugin-mock`：Mock数据支持
  - `vite-plugin-qiankun`：微前端支持

**业务功能库：**
- **ECharts 5.6.0**：数据可视化图表库
- **VXE Table**：高性能虚拟滚动表格
- **TinyMCE 6.6.2**：富文本编辑器
- **Axios 1.7.9**：HTTP请求库
- **Day.js 1.11.13**：轻量级日期处理库
- **Lodash-es 4.17.21**：实用工具库
- **Crypto-js 4.2.0**：加密解密库

**专业特色库：**
- **@jeecg/online**：在线表单设计器
- **@jeecg/aiflow**：AI流程编排组件
- **Qrcode 1.5.4**：二维码生成
- **Print-js 1.6.0**：打印功能
- **Showdown 2.1.0**：Markdown解析器

## 2. 目录结构和文件组织（详细架构）

```
jeecgboot-vue3/
├── src/
│   ├── main.ts                        # 应用入口：初始化、插件注册、微前端适配
│   ├── App.vue                        # 根组件
│   ├── api/                           # 【已弃用】全局API目录
│   │   ├── images/                    # 图片资源
│   │   ├── icons/                     # 图标资源
│   │   └── fonts/                     # 字体资源
│   ├── components/                    # 公共组件库（31个组件模块）
│   │   ├── jeecg/                     # JeecgBoot专用组件
│   │   ├── Table/                     # 通用表格组件
│   │   ├── Form/                      # 通用表单组件
│   │   ├── Modal/                     # 通用模态框组件
│   │   ├── Drawer/                    # 通用抽屉组件
│   │   ├── Upload/                    # 文件上传组件
│   │   ├── Chart/                     # 图表组件封装
│   │   └── registerGlobComp.ts        # 全局组件注册
│   ├── design/                        # 样式设计系统
│   │   ├── index.less                 # 全局样式入口
│   │   ├── var/                       # CSS变量定义
│   │   └── components/                # 组件样式
│   ├── directives/                    # Vue自定义指令
│   │   ├── index.ts                   # 指令注册入口
│   │   ├── permission.ts              # 权限指令
│   │   └── loading.ts                 # 加载指令
│   ├── enums/                         # 枚举常量定义
│   │   ├── pageEnum.ts                # 页面路径枚举
│   │   ├── roleEnum.ts                # 角色枚举
│   │   ├── cacheEnum.ts               # 缓存键枚举
│   │   └── httpEnum.ts                # HTTP相关枚举
│   ├── hooks/                         # 组合式函数（Vue 3 Hooks）
│   │   ├── web/                       # Web相关Hooks
│   │   │   ├── usePermission.ts       # 权限控制Hook
│   │   │   ├── useMessage.ts          # 消息提示Hook
│   │   │   ├── useI18n.ts             # 国际化Hook
│   │   │   └── useSso.ts              # 单点登录Hook
│   │   ├── setting/                   # 设置相关Hooks
│   │   └── system/                    # 系统功能Hooks
│   ├── layouts/                       # 布局组件系统
│   │   ├── default/                   # 默认布局
│   │   │   ├── index.vue              # 主布局组件
│   │   │   ├── header/                # 顶部组件
│   │   │   ├── sider/                 # 侧边栏组件
│   │   │   ├── content/               # 内容区域组件
│   │   │   ├── footer/                # 底部组件
│   │   │   └── tabs/                  # 多标签页组件
│   │   ├── iframe/                    # iframe布局
│   │   └── page/                      # 页面布局
│   ├── locales/                       # 国际化
│   │   ├── lang/                      # 语言包
│   │   │   ├── zh_CN/                 # 中文简体
│   │   │   └── en/                    # 英文
│   │   └── setupI18n.ts               # 国际化配置
│   ├── logics/                        # 业务逻辑
│   │   ├── initAppConfig.ts           # 应用配置初始化
│   │   └── error-handle/              # 错误处理逻辑
│   ├── qiankun/                       # 微前端支持
│   │   ├── index.ts                   # qiankun主应用配置
│   │   ├── micro/                     # 微前端子应用支持
│   │   │   ├── index.ts               # 子应用检测
│   │   │   └── qiankunMicro.ts        # 子应用生命周期
│   │   └── state.ts                   # 微前端状态管理
│   ├── router/                        # 路由系统
│   │   ├── index.ts                   # 路由实例创建
│   │   ├── routes/                    # 路由配置
│   │   │   ├── index.ts               # 路由汇总
│   │   │   ├── basic.ts               # 基础路由
│   │   │   └── modules/               # 模块路由
│   │   ├── guard/                     # 路由守卫
│   │   └── helper/                    # 路由辅助函数
│   ├── settings/                      # 系统设置
│   │   ├── projectSetting.ts          # 项目配置
│   │   ├── siteSetting.ts             # 站点配置
│   │   └── registerThirdComp.ts       # 第三方组件注册
│   ├── store/                         # Pinia状态管理
│   │   ├── index.ts                   # Store入口
│   │   └── modules/                   # Store模块
│   │       ├── app.ts                 # 应用状态
│   │       ├── user.ts                # 用户状态（登录、权限）
│   │       ├── permission.ts          # 权限状态（菜单、路由）
│   │       ├── multipleTab.ts         # 多标签页状态
│   │       └── locale.ts              # 国际化状态
│   ├── utils/                         # 工具函数库
│   │   ├── http/                      # HTTP请求封装
│   │   │   └── axios/                 # Axios配置和拦截器
│   │   ├── auth/                      # 认证相关工具
│   │   ├── cache/                     # 缓存管理工具
│   │   └── encryption/                # 加密解密工具
│   └── views/                         # 页面组件（业务模块）
│       ├── dashboard/                 # 仪表板
│       ├── system/                    # 系统管理
│       │   ├── user/                  # 用户管理
│       │   │   ├── index.vue          # 页面组件
│       │   │   ├── user.api.ts        # API接口
│       │   │   └── user.data.ts       # 配置数据
│       │   ├── role/                  # 角色管理
│       │   └── menu/                  # 菜单管理
│       ├── monitor/                   # 系统监控
│       ├── demo/                      # 演示示例
│       └── parking/                   # 停车管理（自定义模块）
├── build/                             # 构建配置
...
```

## 3. 路由管理机制（混合模式架构）

**路由架构设计：基础路由 + 动态菜单路由**

```typescript
// 路由层级结构
基础路由（静态）
├── 登录页面 (/login)
├── 根路由 (/)
├── OAuth2登录 (/oauth2-app/login)
├── Token登录 (/tokenLogin)
└── 404页面 (/404)

动态路由（后端配置）
├── 仪表板 (/dashboard)
├── 系统管理 (/system/*)
├── 监控管理 (/monitor/*)
└── 业务模块 (/业务路径/*)
```

**路由生命周期：**
```typescript
// 1. 应用启动阶段
createRouter() → setupRouter() → setupRouterGuard()

// 2. 用户登录阶段
login() → afterLoginAction() → getUserInfoAction()

// 3. 权限加载阶段（延迟到首页）
buildRoutesAction() → addRoute() → setDynamicAddedRoute(true)

// 4. 路由跳转阶段
beforeEach守卫 → 权限验证 → 页面渲染
```

**动态路由生成机制：**
```typescript
// 权限路由构建流程
getBackMenuAndPerms() // 获取后端菜单权限
↓
transformObjToRoute() // 转换为Vue Router格式
↓
flatMultiLevelRoutes() // 扁平化多级路由为二级
↓
router.addRoute() // 动态添加路由
↓
setDynamicAddedRoute(true) // 标记路由已构建
```

**路由守卫机制：**
```typescript
// 路由守卫链
router.beforeEach(async (to, from, next) => {
  // 1. 加载进度条
  NProgress.start()

  // 2. 权限验证
  const token = getToken()
  if (!token && !whitePathList.includes(to.path)) {
    next('/login')
    return
  }

  // 3. 动态路由构建（首次访问）
  if (!permissionStore.isDynamicAddedRoute) {
    const routes = await permissionStore.buildRoutesAction()
    routes.forEach(route => router.addRoute(route))
    permissionStore.setDynamicAddedRoute(true)
    next({ ...to, replace: true })
    return
  }

  // 4. 页面级权限验证
  if (!hasPermission(to.meta?.permission)) {
    next('/404')
    return
  }

  next()
})
```

## 4. 组件设计模式（分层架构）

**组件分层体系：**

```
业务页面组件 (views/)
├── 页面容器组件 (index.vue)
├── 业务API接口 (*.api.ts)  
└── 配置数据文件 (*.data.ts)

通用业务组件 (components/)
├── 基础组件封装
│   ├── BasicTable     # 统一表格组件
│   ├── BasicForm      # 统一表单组件
│   ├── BasicModal     # 统一模态框组件
│   └── BasicDrawer    # 统一抽屉组件
├── JeecgBoot专用组件 (jeecg/)
│   ├── JUploadButton  # 上传按钮
│   ├── AIcon          # 图标组件
│   └── 业务组件集
└── 第三方组件封装
    ├── Tinymce        # 富文本编辑器
    ├── Upload         # 文件上传
    └── Chart          # 图表组件

布局组件 (layouts/)
├── DefaultLayout      # 默认后台布局
├── IframeLayout       # iframe布局
└── PageLayout         # 页面布局
```

**标准页面组件模式：**
```vue
<!-- 标准业务页面结构 -->
<template>
  <div class="p-4">  <!-- 不使用PageWrapper -->
    <a-card title="页面标题">
      <!-- 工具栏 -->
      <template #extra>
        <a-space>
          <a-button type="primary" @click="handleAdd">新增</a-button>
          <a-button @click="handleExport">导出</a-button>
        </a-space>
      </template>

      <!-- 表格 -->
      <BasicTable @register="registerTable">
        <template #action="{ record }">
          <TableAction :actions="getTableAction(record)" />
        </template>
      </BasicTable>
    </a-card>

    <!-- 表单抽屉 -->
    <FormDrawer @register="registerDrawer" @success="reload" />
  </div>
</template>

<script setup lang="ts" name="ModuleName">
import { BasicTable, useTable } from '/@/components/Table'
import { useDrawer } from '/@/components/Drawer'
import { columns, searchFormSchema } from './module.data'
import { getList, deleteItem } from './module.api'

// 组件名称：对应后端菜单路径
defineOptions({ name: 'ModuleName' })

// 表格配置
const [registerTable, { reload }] = useTable({
  api: getList,
  columns,
  formConfig: { schemas: searchFormSchema },
  actionColumn: { width: 120 }
})

// 抽屉配置  
const [registerDrawer, { openDrawer }] = useDrawer()
</script>
```

**组件通信模式：**
- **Props + Emits**：父子组件通信
- **Provide/Inject**：跨层级组件通信
- **Pinia Store**：全局状态管理
- **Event Bus**：兄弟组件通信（少用）

## 5. API调用和状态管理（架构设计）

**API组织架构（新模式）：**
```typescript
// 旧模式（已弃用）
src/api/system.ts  // 全局API文件

// 新模式（推荐）
src/views/system/user/user.api.ts  // 与页面组件同级
```

**HTTP请求封装架构：**
```typescript
// 请求拦截器链
beforeRequest → requestInterceptors → API调用 → 
responseInterceptors → transformRequestHook → 业务处理
```

**请求拦截器功能：**
```typescript
requestInterceptors: (config) => {
  // 1. 添加认证Token
  config.headers.Authorization = token
  config.headers['X-Access-Token'] = token

  // 2. 添加租户信息
  config.headers['tenant-id'] = getTenantId()

  // 3. 添加版本标识
  config.headers['version'] = 'v3'

  // 4. 添加接口签名（安全验证）
  config.headers['X-Sign'] = signMd5Utils.getSign(config.url, config.params)
  config.headers['X-TIMESTAMP'] = signMd5Utils.getTimestamp()

  // 5. 微前端路径处理
  if (globSetting.isQiankunMicro) {
    config.url = globSetting.qiankunMicroAppEntry + config.url
  }

  return config
}
```

**状态管理架构（Pinia）：**
```typescript
// Store模块划分
├── app.ts           # 应用配置状态
│   ├── 主题设置
│   ├── 布局配置  
│   ├── 微前端参数
│   └── 项目配置
├── user.ts          # 用户状态
│   ├── 用户信息
│   ├── 登录状态
│   ├── 角色列表
│   ├── 租户信息
│   └── 字典数据
├── permission.ts    # 权限状态
│   ├── 权限代码列表
│   ├── 后台菜单列表
│   ├── 前端菜单列表
│   ├── 动态路由状态
│   └── 权限验证逻辑
├── multipleTab.ts   # 多标签页状态
│   ├── 标签页列表
│   ├── 缓存页面
│   └── 标签页操作
└── locale.ts        # 国际化状态
    ├── 当前语言
    ├── 语言包
    └── 语言切换
```

**权限控制Hook：**
```typescript
// usePermission Hook
export function usePermission() {
  return {
    // 权限判断
    hasPermission: (code: string) => boolean,
    // 禁用判断  
    isDisabledAuth: (code: string) => boolean,
    // 角色变更
    changeRole: (roles: RoleEnum[]) => Promise<void>,
    // 菜单刷新
    refreshMenu: () => Promise<void>
  }
}

// 使用示例
const { hasPermission, isDisabledAuth } = usePermission()

// 模板中使用
<a-button v-if="hasPermission('system:user:add')">新增</a-button>
<a-button :disabled="isDisabledAuth('system:user:delete')">删除</a-button>
```

## 6. 前端开发最佳实践案例

### 6.1. 案例：仪表盘/分析页面的查询控件布局

在JeecgBoot中，标准的列表页（如`BasicTable`页面）通常使用`formConfig`自动生成查询表单，布局规范统一。但对于非标的分析页面或仪表盘页面（例如展示图表的页面），如何优雅地添加一行查询/筛选控件，是一个常见问题。

**1. 问题场景**

假设需要在某个分析卡片（`a-card`）的顶部放置多个筛选条件，如停车场选择器、日期范围选择器、查询按钮等，并要求它们在同一行内水平排列，且风格与框架保持一致。

**2. 错误实践：手动嵌套`a-form`**

一个常见的错误是尝试在`a-card`内手动创建一个`<a-form layout="inline">`或使用复杂的`<a-row>`和`<a-col>`进行布局。这种方式不仅代码冗余，而且很容易出现对齐和换行问题，与JeecgBoot仪表盘（Dashboard）的现有设计风格不符。

**3. 框架推荐模式：利用`extra`插槽**

通过分析框架自带的`dashboard/Analysis/components/SaleTabCard.vue`组件可以发现，JeecgBoot推荐的最佳实践是利用`a-card`或`a-tabs`等容器组件的`extra`（或`rightExtra`）插槽来放置操作项。

**核心实现：**

-   将所有查询控件包裹在一个`<div>`中，并放置在`<a-card>`的`#extra`模板插槽内。
-   为最外层`<div>`添加`class="extra-wrapper"`。
-   为每个独立的查询控件（或`label`+`input`组合）包裹一个`<div>`，并添加`class="extra-item"`。
-   这些样式类（通常是全局或父组件中定义）会利用`display: inline-block`和`margin`等属性，自动处理控件的水平排列和间距。

**4. 代码示例（重构自`OccupancyAnalysis.vue`）**

```vue
<template>
  <a-card :bordered="false">
    <!-- 卡片标题 -->
    <template #title>
      <span>停车场占用率分析</span>
    </template>
    
    <!-- 利用 extra 插槽放置所有查询控件 -->
    <template #extra>
      <div class="extra-wrapper">
        <!-- 每个控件组使用 extra-item 包裹 -->
        <div class="extra-item">
          <span>停车场:</span>
          <a-select v-model:value="queryParam.parkingLotIds" placeholder="请选择停车场" mode="multiple" style="width: 200px"/>
        </div>
        
        <div class="extra-item">
          <span>查询粒度:</span>
          <a-radio-group v-model:value="queryParam.granularity">
            <a-radio-button value="day">按天</a-radio-button>
            <a-radio-button value="month">按月</a-radio-button>
          </a-radio-group>
        </div>

        <div class="extra-item">
          <a-button type="primary" @click="handleQuery">查询</a-button>
          <a-button @click="handleReset">重置</a-button>
        </div>
      </div>
    </template>

    <!-- 图表渲染区域 -->
    <div ref="chartRef" :style="{ height, width }"></div>
  </a-card>
</template>

<style lang="less" scoped>
/* 定义 extra-wrapper 和 extra-item 的样式 */
.extra-wrapper {
  .extra-item {
    display: inline-block;
    margin-right: 24px;

    span {
      margin-right: 8px;
    }
  }
}
</style>
```

**5. 总结**

这种模式是JeecgBoot在仪表盘等非标页面中实现UI一致性的关键。它充分利用了Ant Design Vue组件的插槽机制，避免了复杂的布局代码，使得组件结构更清晰，代码更易于维护，并且完美融入了框架的整体设计风格。在进行类似开发时，应优先遵循此模式。

### 6.2. 案例二：新增标准业务模块的路由集成 (重要)

在JeecgBoot V3项目中，添加一个新的菜单和其对应的页面（例如"设备台账管理"）是一个非常普遍的开发任务。如何正确、安全地将其集成到系统中，是保证项目稳定性的关键。错误的集成方式可能导致难以追踪的全局性问题。

**1. 问题场景**

我们需要在"畜牧管理"菜单下，新增一个"设备台账管理"子菜单。点击该菜单后，应能正确地展示我们已经开发好的 `DeviceList.vue` 页面，并且整个过程不能影响系统其他模块的正常运行。

**2. 错误实践：修改核心路由文件**

一个常见且**极其危险**的错误是，尝试通过**手动修改核心路由文件 `src/router/routes/index.ts`** 来实现新路由的注册。

```typescript
// src/router/routes/index.ts (错误的做法，请勿模仿!)
import system from './modules/system';
import account from './modules/account';
// 1. 手动导入新建的路由文件
import animalHusbandry from './modules/animalHusbandry'; 

// ...
// 2. 手动将导入的模块push到路由列表
routeModuleList.push(system);
routeModuleList.push(account);
routeModuleList.push(animalHusbandry); 
// ...
```

这种做法的**严重弊端**在于：
*   **破坏了自动化机制**：它完全绕过了框架设计好的、基于 `import.meta.glob` 的模块自动化扫描机制。
*   **引发未知冲突**：可能导致路由重复注册，或改变了路由加载的顺序，从而引发类似我们之前遇到的"获取用户权限失败"等全局性的初始化问题。
*   **极难维护**：随着模块增多，`index.ts` 会变得异常臃肿，且在多人协作时极易产生代码合并冲突。

**3. 框架推荐模式：模块化与自动化**

JeecgBoot V3 遵循"约定优于配置"的原则，提供了优雅的模块化路由解决方案。正确的做法是，我们**永远不需要修改 `src/router/routes/index.ts`**。

**第一步：在 `views` 目录下创建页面组件**
这部分是标准的页面开发，例如我们创建的 `jeecgboot-vue3/src/views/animal_husbandry/device/DeviceList.vue`。

**第二步：在页面组件中定义 `name` (权限关键)**
在 `DeviceList.vue` 的 `<script>` 部分，必须使用 `defineOptions` 来定义组件的 `name`。

```vue
// DeviceList.vue
<script lang="ts" setup name="animal_husbandry/device">
  // ...
  defineOptions({ name: 'animal_husbandry/device' });
  // ...
</script>
```
*   **核心要点**：此处的 `name` **不是随意的**，它必须与后端 `系统管理 -> 菜单管理` 中为"设备台账管理"这个菜单所配置的 **"组件路径"** 字段的值完全一致。这是JeecgBoot实现按钮级别权限控制的绑定关键。

**第三步：在 `modules` 目录下创建独立的路由文件**
在 `src/router/routes/modules/` 目录下，为我们的新功能创建一个独立的、以其功能命名的路由文件，例如 `animalHusbandry.ts`。

```typescript
// src/router/routes/modules/animalHusbandry.ts (正确的做法)
import type { AppRouteModule } from '/@/router/types';
import { LAYOUT } from '/@/router/constant';

const animalHusbandry: AppRouteModule = {
  path: '/animal-husbandry',
  name: 'AnimalHusbandry', // 顶级菜单的name
  component: LAYOUT,
  redirect: '/animal-husbandry/device',
  meta: {
    orderNo: 20, // 排序号
    icon: 'ant-design:appstore-outlined',
    title: '畜牧管理',
  },
  children: [
    {
      path: 'device',
      name: 'AnimalHusbandryDevice', // 子菜单的name
      component: () => import('/@/views/animal_husbandry/device/DeviceList.vue'),
      meta: {
        title: '设备台账管理',
        icon: 'ant-design:database-outlined',
      },
    },
  ],
};

export default animalHusbandry;
```

**第四步：完成！**
是的，这样就完成了。因为 `src/router/routes/index.ts` 会自动扫描 `modules` 目录下的所有 `.ts` 文件并加载它们导出的路由配置。

**4. 总结：安全集成的三原则**

*   **隔离原则**：新功能的路由配置必须在 `modules` 目录下以独立文件存在，绝不能侵入 `index.ts`。
*   **约定原则**：相信并遵循框架的约定，包括目录结构约定和组件`name`与后端权限的绑定约定。
*   **最小改动原则**：添加一个功能齐全的模块，最理想的情况是只进行"新增文件"的操作，而无需修改任何已有的核心框架文件。

### 6.3. 案例四：表格横向滚动与固定列的正确实现

在JeecgBoot项目中，当`BasicTable`的列数过多时，如何正确地实现横向滚动条，同时将重要的操作列固定在右侧，是一个非常常见的需求。错误或不规范的配置会导致滚动条不出现或行为异常。

**1. 问题场景**

一个标准的列表页，因包含字段较多，导致表格宽度超出了屏幕可视范围。开发者希望：
*   表格出现水平滚动条。
*   最右侧的"操作"列在表格左右滚动时，始终保持固定可见。

**2. 错误实践：硬编码与错误的根源定位**

*   **错误做法一：迷信`scroll`属性**
    开发者可能会首先尝试在`useTable`的`tableProps`中添加`scroll: { x: true }`。但在某些情况下，这并不会生效，因为表格的总宽度可能未被正确计算。

*   **错误做法二：硬编码"魔法数字"**
    当`scroll: { x: true }`不生效时，一个常见的"暴力"解决方法是给`x`一个固定的超大值，例如`scroll: { x: 1500 }`。这种做法虽然能强制显示滚动条，但它有**严重缺陷**：
    *   **治标不治本**：它掩盖了滚动条不出现的真正原因。
    *   **缺乏响应性**：该固定值无法适应不同屏幕尺寸和动态变化的列宽。
    *   **违反框架设计**：它绕过了框架本应具备的自适应能力。

**3. 框架推荐模式：启用`canResize`是关键**

通过深入分析`BasicTable`及其`useTable`钩子的实现可以发现，滚动条能否出现的**真正根源**，在于`canResize`这个属性。

*   **核心要点**：`canResize`属性不仅仅控制用户是否能拖动列宽，它更是**激活表格布局自适应计算的关键开关**。当`canResize: false`时，表格会倾向于使用固定布局，从而可能忽略`scroll`配置。

*   **最佳实践**：要实现稳定可靠的横向滚动和列固定，必须采用以下组合配置：
    1.  **`canResize: true`**：这是**必须**的。将此项设置为`true`，以"解锁"表格的自适应宽度计算和滚动能力。
    2.  **`actionColumn: { fixed: 'right' }`**：在`actionColumn`配置中，使用`fixed: 'right'`来将操作列标准地固定在右侧。
    3.  **（可选）为`scroll`设置一个动态或内容适配值**：在启用了`canResize`后，通常无需再设置`scroll`。但如果需要更精细的控制，可以不设置`x`值，或将其设置为一个基于内容的标识，而不是固定的像素值。

**4. 代码示例（`AnimalList.vue`中的正确配置）**

```vue
// AnimalList.vue
<script lang="ts" setup>
// ...
const { tableContext, onExportXls, onImportXls } = useListPage({
  tableProps: {
    title: '牲畜档案管理',
    api: getList,
    columns,
    // 关键一：必须设置为true，启用表格的自适应布局和滚动能力
    canResize: true,
    formConfig: {
      //...
    },
    actionColumn: {
      width: 360,
      title: '操作',
      dataIndex: 'action',
      slots: { customRender: 'action' },
      // 关键二：使用fixed属性标准地固定操作列
      fixed: 'right',
    },
  },
  // ...
});
//...
</script>
```

**5. 总结**

在处理JeecgBoot前端表格的复杂布局问题时，应当优先理解并利用框架提供的配置项（如`canResize`），而不是通过硬编码的方式去覆盖其默认行为。**`canResize: true`是实现`BasicTable`自适应滚动的前提**，这应作为一条核心开发准则。

**补充说明：标准插槽是前提**
> 值得注意的是，以上所有关于`actionColumn`的配置（包括`width`, `fixed`, `slots`等）能够正确生效的一个重要前提是：在Vue模板中，必须使用框架推荐的、专门的`#action`插槽来承载`<TableAction>`组件。如果错误地使用了通用的`#bodyCell`插槽来渲染操作列，会导致`actionColumn`中的`slots: { customRender: 'action' }`配置失效，从而使操作列显示为空白。因此，保持模板结构的规范性是功能正常工作的基础。
</rule>
